TODO:

from_fastfuels method to set up domain
Change structure of module (brainstorm):
    - duet-tools : Calibrator :: quicfire-tools : SimulationInputs
    - duet-tools : FuelType :: quicfire-tools : InputFile
    - duet-tools : fuel types :: quicfire-tools : input files
        - Grass
        - Litter
    
    duet_run = Calibrator.import_duet(nx,ny,nz)
    duet_run.grass.assign_targets(min = 0.2, max = 1.0)
    duet_run.litter.assign_targets(mean = 0.5, sd = 0.05)
    duet_run.litter.add_tree_species("longleaf_pine", layer = 2)
    duet_run.litter.longleaf_pine.assign_targets(min = 0.8, max = 0.8)

    Once you've assigned targets to each fuel type, then you can calibrate them.
    They will calibrate based on whatever targets you supplied, and will throw an
    error if no targets are assigned.

    duet_run.grass.calibrate()
    duet_run.litter.calibrate()

    Then we can either spit out an array, or write to a dat file
    duet_run.to_numpy()
    duet_run.to_numpy(fuel_types = 'litter')
    duet_run.to_file(combine = True)

    ^ The argument fuel_types should take 'all' (default), 'grass', 'litter', or any of the tree species.
    It should be in both to_numpy and to_file. Both should also have a combine argument, probably set to False.

    That should get me started

    How should I access arrays? Probably just through to_numpy and to_file
        - store in a dict!

    How to do .assign_targets for different arrays?
        - .target_moisutre(sb40 = False, min = None, max = None, mean = None, sd = None)
        - .target_bulk_density()
        - .target_height()
        - Then to calibrate:
            - duet_run.grass.calibrate(bulk_denstiy = True, moisture = True, height = True)
    
    So now the workflow is:
    duet_run = Calibrator.import_duet(dir,nx,ny,nz)
    duet_run.grass.target_bulk_density(sb40=True)
    duet_run.grass.target_height(min = 0.5, max = 0.5)
    duet_run.grass.target_moisture(mean = 0.2, sd = 0.01)
    duet_run.litter.add_tree_species("longleaf_pine", layer = 1)
    duet_run.litter.add_tree_species("turkey_oak", layer = 2)
    duet_run.litter.longleaf_pine.target_bulk_density(mean...)

DUET DOESNT EXPORT MOISTURE!!

When we assign targets for bulk density, are we assigning CELL bulk density, or FUEL bulk density?
Would it make more sense to assign FUEL bulk density??
Does DUET have a constant fuel bulk density that it uses to calculate cell bulk density? NO!

Switch from OOP to FP:
    - Brainstorm how it would be used
        # first create DuetRun class using import_duet
        duet_run = import_duet(directory, nx, ny, nz)

        # assign targets from user
        litter_moisture = assign_targets(method = "constant", constant)
        litter_density = assign_targets(method = "maxmin", max, min)
        litter_depth = assign_targets(method = "maxmin", max, min)

        # assign targets from landfire
        unit_fastfuels = get_unit_from_fastfuels(zroot)
        unit_geojson = get_unit_from_geojson(directory)
        grass_sb40 = assign_targets(method = "sb40", bbox = unit_geojson)

        # combine targets for each fuel type
        litter_targets = fueltype_targets(moisture=litter_moisture,density=litter_density,depth=litter_depth)
        grass_targets = fueltype_targets(moisture=grass_sb40,density=grass_sb40,depth=grass_sb40)
        
        # use the calibrate function to create a new DuetRun object
        calibrated_duet = calibrate(duet_run, grass=grass_targets, litter=litter_targets)

        # access arrays from DuetRun
        litter_moisture = calibrated_duet.to_numpy(fueltype = "litter", parameter = "moisture")
        separated_density = calibrated_duet.to_numpy(fueltype = "separated", parameter = "density") #3D array of all fuels
        integrated_depth = calibrated_duet.to_numpy(fueltype = "integrated", parameter = "depth") #2D array of all fuels

        # write to dat file(s)
        duet_run.to_quicfire(directory) # writes treesrhof.dat, treesmoist.dat, and treesfueldepth.dat 
        write_numpy_to_quicfire(litter_moisture, directory, "treesmoist.dat")

    - Notes:
        Objects:
            - DuetRun: stores arrays, has to_numpy and to_file methods
            - Targets: stores target methods and values
            - FuelParameters: stores and VALIDATES targets for each fuel type
        Definitely not sure Targets and FuelParameters should exist...
        When method = "sb40", the bbox argument should potentially be:
            - a geojson
            - a shapely polyon
            - a list or dict of coordinates
